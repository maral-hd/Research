\section{Methodology}
\label{sec:method}

To support our regression test generation approach 
for web applications, we have developed PARTE (PHP 
Analysis and Regression Testing Engine).
Figure~\ref{fig:overview} summarizes PARTE's three 
main activities (light green boxes) and how these 
activities are related to each other.
Although we implemented the regression test generation technique
that is applied to PHP web applications, the methodology we apply 
here can easily be applied to other languages by extending the 
front end file conversion functionality.   
When we generate test cases, we considered test paths and input
values that make test paths executable. Another important component 
of test cases is test oracles that verify test results, however, 
in this work, we have not considered test oracles, and we discuss
the limitation of our work related to the test oracle issue in 
Section~\ref{sec:limitations}.

%\begin{figure*}[ht]
\begin{figure*}[!ht]
%\vspace*{-5pt}
\centering
\includegraphics[width=0.8\columnwidth]{figures/parte-overview.pdf}
%    \includegraphics[width=0.8\textwidth]{figures/overview.eps}
\vspace*{-40pt}
 \caption{Overview of PARTE} 
\label{fig:overview}
\end{figure*}

Before we describe each activity in detail,
we provide a brief overview of our approach.

\begin{smallitem}
\item {\bf Preprocessing} (the upper-left box in Figure~\ref{fig:overview}).
In this step, PARTE converts abstract syntax trees (ASTs) generated by
a PHP compiler, PHC~\cite{phc}, to high-level
intermediate representation (HIR) that preserves variable
names and converts this HIR back to ASTs.   

\item {\bf Impact Analysis} (the lower box in Figure~\ref{fig:overview}).
Using preprocessed files, a PDG (Program Dependence Graph) generator 
builds PDGs for the two consecutive versions of a PHP web application. 
Then, a differencing tool and a program slicer identify 
the affected areas by the code changes (program slices).

\item {\bf Test Case Generation} (the upper-right box 
in Figure~\ref{fig:overview}).
A test path generator creates test paths using program slices. 
A constraint collector/resolver gathers string and numeric 
input constraints, and resolves them using a constraint 
solver, Choco~\cite{choco}.
Finally, a test execution engine takes these resolved input 
values, executes the application through Selenium~\cite{selenium},
and records the test execution results.
The last step is done manually because the current path 
generator does not provide web elements for Selenium.
 
\end{smallitem}

\input{ast.tex}
\input{impact.tex}
\input{testgen.tex}

